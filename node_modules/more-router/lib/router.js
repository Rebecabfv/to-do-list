"use strict";

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var IDENTIFIER = /^[^\d\W]\w*$/;
var PATH_VARIABLE = /\{([^}]*)\}/g;
var VARIABLE = "{}";
var PATH_SEPARATOR = /\/+/;

var Router = (function () {
    function Router() {
        _classCallCheck(this, Router);

        this.root = new Node();
        this.registered = new Map();
    }

    _prototypeProperties(Router, null, {
        addPattern: {
            value: function addPattern(path, value) {
                this.registered.set(normalizePath(path), value);
                var node = this.root;
                var knownVariables = new Set();
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = parsePath(path)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var segment = _step.value;

                        var step = new Step(segment);
                        node = node.add(step);
                        // XXX duplicate variables check
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                node.value = value;
            },
            writable: true,
            configurable: true
        },
        getPattern: {
            value: function getPattern(path) {
                return this.registered.get(normalizePath(path));
            },
            writable: true,
            configurable: true
        },
        consume: {
            value: function consume(stack) {
                stack = stack.slice();
                var node = this.root;
                var variables = {};
                while (stack.length > 0) {
                    var segment = stack.pop();
                    var found = node.get(segment);
                    if (found.node === null) {
                        stack.push(segment);
                        return {
                            value: node.value,
                            stack: stack,
                            variables: variables
                        };
                    }
                    node = found.node;
                    Object.assign(variables, found.variables);
                }
                return {
                    value: node.value,
                    stack: stack,
                    variables: variables
                };
            },
            writable: true,
            configurable: true
        },
        resolve: {
            value: function resolve(path) {
                var steps = parsePath(path);
                steps.reverse();
                return this.consume(steps);
            },
            writable: true,
            configurable: true
        }
    });

    return Router;
})();

module.exports = Router;

var Step = (function () {
    function Step(s) {
        _classCallCheck(this, Step);

        this.s = s;
        this.generalized = generalizeVariables(s);
        this.variablesRe = createVariablesRe(s);
        this.names = parseVariables(s);
        this.parts = this.generalized.split("{}");
    }

    _prototypeProperties(Step, null, {
        match: {
            value: function match(s) {
                var matched = this.variablesRe.exec(s);
                if (matched === null) {
                    return {
                        matched: false,
                        variables: {}
                    };
                }
                matched = matched.slice(1);
                var result = {};
                for (var i = 0; i < this.names.length; i++) {
                    result[this.names[i]] = matched[i];
                }
                return {
                    matched: true,
                    variables: result
                };
            },
            writable: true,
            configurable: true
        },
        hasVariables: {
            value: function hasVariables() {
                return this.names.length > 0;
            },
            writable: true,
            configurable: true
        },
        greaterThan: {
            value: function greaterThan(other) {
                if (isSame(this.parts, other.parts)) {
                    return false;
                }
                return !this.lesserThan(other);
            },
            writable: true,
            configurable: true
        },
        lesserThan: {
            value: function lesserThan(other) {
                if (isSame(this.parts, other.parts)) {
                    return false;
                }
                if (this.variablesRe.exec(other.s) !== null) {
                    return false;
                }
                if (other.variablesRe.exec(this.s) !== null) {
                    return true;
                }
                return greaterThan(this.parts, other.parts);
            },
            writable: true,
            configurable: true
        }
    });

    return Step;
})();

;

var Node = (function () {
    function Node() {
        _classCallCheck(this, Node);

        this.nameNodes = new Map();
        this.variableNodes = [];
        this.value = null;
    }

    _prototypeProperties(Node, null, {
        add: {
            value: function add(step) {
                if (!step.hasVariables()) {
                    return this.addNameNode(step);
                }
                return this.addVariableNode(step);
            },
            writable: true,
            configurable: true
        },
        addNameNode: {
            value: function addNameNode(step) {
                var node = this.nameNodes.get(step.s);
                if (node !== undefined) {
                    return node;
                }
                node = new StepNode(step);
                this.nameNodes.set(step.s, node);
                return node;
            },
            writable: true,
            configurable: true
        },
        addVariableNode: {
            value: function addVariableNode(step) {
                for (var i = 0; i < this.variableNodes.length; i++) {
                    var node = this.variableNodes[i];
                    if (node.step === step) {
                        return node;
                    }
                    if (node.step.generalized === step.generalized) {}
                    if (step.greaterThan(node.step)) {
                        continue;
                    }
                    var _result = new StepNode(step);
                    this.variableNodes.splice(i, 0, _result);
                    return _result;
                }
                var result = new StepNode(step);
                this.variableNodes.push(result);
                return result;
            },
            writable: true,
            configurable: true
        },
        get: {
            value: function get(segment) {
                var node = this.nameNodes.get(segment);
                if (node !== undefined) {
                    return { node: node, variables: {} };
                }
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = this.variableNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var _node = _step.value;

                        var matched = _node.match(segment);
                        if (matched.matched) {
                            return { node: _node, variables: matched.variables };
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                return { node: null, variables: {} };
            },
            writable: true,
            configurable: true
        }
    });

    return Node;
})();

var StepNode = (function (Node) {
    function StepNode(step) {
        _classCallCheck(this, StepNode);

        _get(Object.getPrototypeOf(StepNode.prototype), "constructor", this).call(this);
        this.step = step;
    }

    _inherits(StepNode, Node);

    _prototypeProperties(StepNode, null, {
        match: {
            value: function match(segment) {
                return this.step.match(segment);
            },
            writable: true,
            configurable: true
        }
    });

    return StepNode;
})(Node);

function parsePath(path) {
    return normalizePath(path).split(PATH_SEPARATOR);
}

function normalizePath(path) {
    if (path.startsWith("/")) {
        path = path.slice(1);
    }
    if (path.endsWith("/")) {
        path = path.slice(0, -1);
    }
    return path;
};

function generalizeVariables(s) {
    return s.replace(PATH_VARIABLE, "{}");
}

function createVariablesRe(s) {
    return new RegExp("^" + s.replace(PATH_VARIABLE, "(.+)") + "$");
};

function parseVariables(s) {
    var result = PATH_VARIABLE.exec(s);
    if (result === null) {
        return [];
    }
    return result.slice(1);
};

function isSame(one, two) {
    if (one.length !== two.length) {
        return false;
    }
    for (var i = 0; i < one.length; i++) {
        if (one[i] !== two[i]) {
            return false;
        }
    }
    return true;
};

function greaterThan(one, two) {
    for (var i = 0; i < one.length; i++) {
        if (i > two.length) {
            return true;
        }
        if (one[i] > two[i]) {
            return true;
        }
    }
    return false;
};

// raise new Error(
//     `step ${node.step.s} and ${step.s} are in conflict`);