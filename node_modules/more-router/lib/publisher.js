"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var NestedMap = _interopRequire(require("./nestedmap"));

var Router = _interopRequire(require("./router"));

var Publisher = (function () {
    function Publisher(keySpec) {
        _classCallCheck(this, Publisher);

        this.keySpec = keySpec;
        this.router = new Router();
    }

    _prototypeProperties(Publisher, null, {
        register: {
            value: function register(path, keyObj, value) {
                var m = this.router.getPattern(path);
                if (m === undefined) {
                    m = new NestedMap(this.keySpec);
                    this.router.addPattern(path, m);
                }
                m.set(keyObj, value);
            },
            writable: true,
            configurable: true
        },
        resolve: {
            value: function resolve(path, request) {
                // first get NestedMap based on path

                var _router$resolve = this.router.resolve(path);

                var value = _router$resolve.value;
                var stack = _router$resolve.stack;
                var variables = _router$resolve.variables;

                if (value === null) {
                    return null;
                }
                // determine view name we want and put on request
                var viewName = undefined;
                if (stack.length === 0) {
                    viewName = "";
                } else if (stack.length === 1) {
                    viewName = stack[0];
                } else {
                    return null;
                }
                request.viewName = viewName;
                // now construct keyObj
                var keyObj = {};
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = this.keySpec[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        (function () {
                            var keySpec = _step.value;

                            var extract = keySpec.extract;
                            if (extract === undefined) {
                                extract = function (request) {
                                    return request[keySpec.name];
                                };
                            }
                            keyObj[keySpec.name] = extract(request);
                        })();
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                // see whether anything matches view predicates
                var result = value.get(keyObj);
                if (result === undefined) {
                    return null;
                }
                // if so, call it with variables and request
                return result(variables, request);
            },
            writable: true,
            configurable: true
        }
    });

    return Publisher;
})();

module.exports = Publisher;