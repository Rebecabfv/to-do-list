"use strict";

var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var NestedMap = (function () {
    function NestedMap(keySpec) {
        _classCallCheck(this, NestedMap);

        this.keySpec = keySpec;
        this.map = new Map();
    }

    _prototypeProperties(NestedMap, null, {
        normalizeKey: {
            value: function normalizeKey(keyObj) {
                var result = [];
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = this.keySpec[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var keySpec = _step.value;

                        var key = keyObj[keySpec.name];
                        if (key === undefined) {
                            key = keySpec.defaultKey;
                        }
                        result.push(key);
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                ;
                return result;
            },
            writable: true,
            configurable: true
        },
        set: {
            value: function set(keyObj, value) {
                var normalizedKey = this.normalizeKey(keyObj);
                var m = this.map;
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = normalizedKey.slice(0, -1)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var key = _step.value;

                        var sub = m.get(key);
                        if (sub === undefined) {
                            sub = new Map();
                            m.set(key, sub);
                        }
                        m = sub;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                m.set(normalizedKey[normalizedKey.length - 1], value);
            },
            writable: true,
            configurable: true
        },
        get: {
            value: function get(keyObj) {
                var normalizedKey = this.normalizeKey(keyObj);
                var m = this.map;
                var depth = 0;
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                    for (var _iterator = normalizedKey[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                        var key = _step.value;

                        m = m.get(key);
                        if (m === undefined) {
                            return this.keySpec[depth].fallback;
                        }
                        depth++;
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion && _iterator["return"]) {
                            _iterator["return"]();
                        }
                    } finally {
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }

                return m;
            },
            writable: true,
            configurable: true
        }
    });

    return NestedMap;
})();

module.exports = NestedMap;